import type { NodeDefinition, NodeType } from "@/types/nodes";

/** Category ID for UI (maps cep-pattern to pattern for backward compatibility) */
export type NodeCategoryId = "source" | "pattern" | "transform" | "sink";

export const NODE_CATEGORIES: {
  id: NodeCategoryId;
  label: string;
  color: string;
  nodes: NodeType[];
}[] = [
  {
    id: "source",
    label: "Sources",
    color: "blue",
    nodes: [
      "kafka-topic",
      "delta-table-source",
      "auto-loader",
      "rest-webhook-source",
      "cdc-stream",
      "event-hub-kinesis",
      "mqtt",
      "custom-python-source",
      "stream-simulator",
      "google-pubsub",
    ],
  },
  {
    id: "pattern",
    label: "CEP Patterns",
    color: "purple",
    nodes: [
      "sequence-detector",
      "absence-detector",
      "count-threshold",
      "velocity-detector",
      "geofence-location",
      "temporal-correlation",
      "trend-detector",
      "outlier-anomaly",
      "session-detector",
      "deduplication",
      "match-recognize-sql",
      "custom-stateful-processor",
      "state-machine",
      "heartbeat-liveness",
    ],
  },
  {
    id: "transform",
    label: "Transforms",
    color: "green",
    nodes: [
      "filter",
      "map-select",
      "flatten-explode",
      "lookup-enrichment",
      "window-aggregate",
      "stream-stream-join",
      "stream-static-join",
      "union-merge",
      "rename-cast",
      "custom-python-udf",
      "ml-model-endpoint",
      "split-router",
      "watermark",
      "data-quality-expectations",
    ],
  },
  {
    id: "sink",
    label: "Sinks",
    color: "orange",
    nodes: [
      "delta-table-sink",
      "kafka-topic-sink",
      "rest-webhook-sink",
      "slack-teams-pagerduty",
      "email-sink",
      "sql-warehouse-sink",
      "unity-catalog-table-sink",
      "dead-letter-queue",
      "feature-store-sink",
      "lakebase-sink",
    ],
  },
];

// Shared CEP advanced fields used by all CEP pattern nodes
const CEP_ADVANCED_FIELDS = [
  {
    key: "groupByKeys",
    label: "Group By Keys",
    type: "column-picker" as const,
    required: false,
    placeholder: "Select columns for partitioning",
    helpText: "Columns to partition the pattern matching by",
    group: "Advanced",
  },
  {
    key: "watermarkDuration",
    label: "Watermark Duration",
    type: "duration" as const,
    required: false,
    defaultValue: { value: 10, unit: "minutes" },
    helpText: "Watermark delay for late event handling",
    group: "Advanced",
  },
  {
    key: "checkpointInterval",
    label: "Checkpoint Interval",
    type: "duration" as const,
    required: false,
    defaultValue: { value: 1, unit: "minutes" },
    helpText: "Interval for state checkpointing",
    group: "Advanced",
  },
  {
    key: "stateTtl",
    label: "State TTL",
    type: "duration" as const,
    required: false,
    helpText: "Time-to-live for pattern state",
    group: "Advanced",
  },
  {
    key: "quantifiers",
    label: "Quantifiers",
    type: "select" as const,
    required: false,
    defaultValue: "greedy",
    options: [
      { value: "greedy", label: "Greedy" },
      { value: "reluctant", label: "Reluctant" },
    ],
    helpText: "Pattern quantifier behavior",
    group: "Advanced",
  },
  {
    key: "outputMeasures",
    label: "Output Measures",
    type: "expression" as const,
    required: false,
    placeholder: "MATCH_NUMBER(), CLASSIFIER(), ...",
    helpText: "Measures to include in output (SQL expressions)",
    group: "Advanced",
  },
];

export const NODE_REGISTRY: Record<NodeType, NodeDefinition> = {
  // ============ SOURCES (8) ============
  "kafka-topic": {
    type: "kafka-topic",
    label: "Kafka Topic",
    description: "Read streaming data from Kafka topics",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "MessageSquare",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "bootstrapServers",
        label: "Bootstrap Servers",
        type: "text",
        required: true,
        placeholder: "host1:9092,host2:9092",
        helpText: "Comma-separated list of Kafka broker addresses",
        group: "Connection",
      },
      {
        key: "topics",
        label: "Topics",
        type: "text",
        required: true,
        placeholder: "topic1,topic2",
        helpText: "Comma-separated topic names or regex pattern",
        group: "Connection",
      },
      {
        key: "consumerGroup",
        label: "Consumer Group",
        type: "text",
        required: true,
        placeholder: "my-consumer-group",
        helpText: "Consumer group ID for offset management",
        group: "Connection",
      },
      {
        key: "startingOffset",
        label: "Starting Offset",
        type: "select",
        required: true,
        defaultValue: "latest",
        options: [
          { value: "earliest", label: "Earliest" },
          { value: "latest", label: "Latest" },
          { value: "timestamp", label: "Specific Timestamp" },
        ],
        group: "Offset",
      },
      {
        key: "startingTimestamp",
        label: "Starting Timestamp",
        type: "text",
        required: false,
        placeholder: "2024-01-01T00:00:00Z",
        dependsOn: { field: "startingOffset", value: "timestamp" },
        group: "Offset",
      },
      {
        key: "schemaSource",
        label: "Schema Source",
        type: "select",
        required: true,
        defaultValue: "infer",
        options: [
          { value: "registry", label: "Schema Registry" },
          { value: "manual", label: "Manual Definition" },
          { value: "infer", label: "Infer from Data" },
        ],
        group: "Schema",
      },
      {
        key: "schemaRegistryUrl",
        label: "Schema Registry URL",
        type: "text",
        required: false,
        placeholder: "http://schema-registry:8081",
        dependsOn: { field: "schemaSource", value: "registry" },
        group: "Schema",
      },
      {
        key: "deserializationFormat",
        label: "Deserialization Format",
        type: "select",
        required: true,
        defaultValue: "json",
        options: [
          { value: "json", label: "JSON" },
          { value: "avro", label: "Avro" },
          { value: "protobuf", label: "Protobuf" },
        ],
        group: "Schema",
      },
    ],
  },

  "delta-table-source": {
    type: "delta-table-source",
    label: "Delta Table Source",
    description: "Stream changes from a Delta table",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Database",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "catalog",
        label: "Catalog",
        type: "text",
        required: true,
        placeholder: "main",
        group: "Table",
      },
      {
        key: "schema",
        label: "Schema",
        type: "text",
        required: true,
        placeholder: "default",
        group: "Table",
      },
      {
        key: "table",
        label: "Table",
        type: "text",
        required: true,
        placeholder: "my_table",
        group: "Table",
      },
      {
        key: "startingVersion",
        label: "Starting Version",
        type: "text",
        required: false,
        placeholder: "0 or latest",
        defaultValue: "latest",
        helpText: "Delta table version to start reading from",
        group: "Stream Options",
      },
      {
        key: "ignoreDeletes",
        label: "Ignore Deletes",
        type: "toggle",
        required: false,
        defaultValue: false,
        helpText: "Ignore DELETE operations in the stream",
        group: "Stream Options",
      },
    ],
  },

  "auto-loader": {
    type: "auto-loader",
    label: "Auto Loader",
    description: "Incremental file ingestion from cloud storage",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "FolderInput",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "cloudPath",
        label: "Cloud Path",
        type: "text",
        required: true,
        placeholder: "s3://bucket/path/ or abfss://container@account.dfs.core.windows.net/path/",
        helpText: "Cloud storage path (S3, ADLS, GCS)",
        group: "Path",
      },
      {
        key: "fileFormat",
        label: "File Format",
        type: "select",
        required: true,
        defaultValue: "json",
        options: [
          { value: "json", label: "JSON" },
          { value: "csv", label: "CSV" },
          { value: "parquet", label: "Parquet" },
          { value: "avro", label: "Avro" },
        ],
        group: "Format",
      },
      {
        key: "schemaLocation",
        label: "Schema Location",
        type: "text",
        required: false,
        placeholder: "s3://bucket/schema/",
        helpText: "Path to store inferred schema",
        group: "Schema",
      },
      {
        key: "schemaHints",
        label: "Schema Hints",
        type: "expression",
        required: false,
        placeholder: "id LONG, name STRING, ts TIMESTAMP",
        helpText: "Optional schema hints for inference",
        group: "Schema",
      },
    ],
  },

  "rest-webhook-source": {
    type: "rest-webhook-source",
    label: "REST/Webhook Source",
    description: "Receive events via HTTP REST or webhook",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Webhook",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "listenPort",
        label: "Listen Port",
        type: "number",
        required: true,
        defaultValue: 8080,
        validation: { min: 1, max: 65535 },
        group: "Server",
      },
      {
        key: "path",
        label: "Webhook Path",
        type: "text",
        required: true,
        placeholder: "/webhook/events",
        group: "Server",
      },
      {
        key: "authType",
        label: "Auth Type",
        type: "select",
        required: true,
        defaultValue: "none",
        options: [
          { value: "none", label: "None" },
          { value: "bearer", label: "Bearer Token" },
          { value: "basic", label: "Basic Auth" },
          { value: "api-key", label: "API Key Header" },
        ],
        group: "Auth",
      },
      {
        key: "authSecret",
        label: "Auth Secret",
        type: "text",
        required: false,
        placeholder: "Secret value",
        dependsOn: { field: "authType", value: "bearer" },
        group: "Auth",
      },
      {
        key: "payloadSchema",
        label: "Payload Schema",
        type: "schema-picker",
        required: false,
        codeLanguage: "json",
        helpText: "Expected JSON schema for incoming payloads",
        group: "Schema",
      },
    ],
  },

  "cdc-stream": {
    type: "cdc-stream",
    label: "CDC Stream",
    description: "Change Data Capture from database logs",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "RefreshCw",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "kafkaTopic",
        label: "Kafka Topic",
        type: "text",
        required: true,
        placeholder: "db.cdc.events",
        helpText: "Kafka topic containing CDC events",
        group: "Connection",
      },
      {
        key: "cdcFormat",
        label: "CDC Format",
        type: "select",
        required: true,
        defaultValue: "debezium",
        options: [
          { value: "debezium", label: "Debezium" },
          { value: "maxwell", label: "Maxwell" },
          { value: "spark-cdc", label: "Spark CDC" },
        ],
        group: "Format",
      },
      {
        key: "primaryKeys",
        label: "Primary Keys",
        type: "column-picker",
        required: true,
        placeholder: "Select primary key columns",
        group: "Schema",
      },
      {
        key: "schema",
        label: "Schema Definition",
        type: "schema-picker",
        required: false,
        helpText: "Expected schema for CDC records",
        group: "Schema",
      },
    ],
  },

  "event-hub-kinesis": {
    type: "event-hub-kinesis",
    label: "Event Hub / Kinesis",
    description: "Azure Event Hub or AWS Kinesis stream",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Radio",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "provider",
        label: "Provider",
        type: "select",
        required: true,
        options: [
          { value: "event-hub", label: "Azure Event Hub" },
          { value: "kinesis", label: "AWS Kinesis" },
        ],
        group: "Connection",
      },
      {
        key: "connectionString",
        label: "Connection String",
        type: "text",
        required: false,
        placeholder: "Endpoint=sb://...",
        dependsOn: { field: "provider", value: "event-hub" },
        group: "Connection",
      },
      {
        key: "streamArn",
        label: "Stream ARN",
        type: "text",
        required: false,
        placeholder: "arn:aws:kinesis:...",
        dependsOn: { field: "provider", value: "kinesis" },
        group: "Connection",
      },
      {
        key: "consumerGroup",
        label: "Consumer Group",
        type: "text",
        required: true,
        placeholder: "my-consumer-group",
        group: "Connection",
      },
      {
        key: "startingPosition",
        label: "Starting Position",
        type: "select",
        required: true,
        defaultValue: "latest",
        options: [
          { value: "earliest", label: "Earliest" },
          { value: "latest", label: "Latest" },
          { value: "trim-horizon", label: "Trim Horizon" },
        ],
        group: "Offset",
      },
    ],
  },

  mqtt: {
    type: "mqtt",
    label: "MQTT",
    description: "Subscribe to MQTT broker topics",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Wifi",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "brokerUrl",
        label: "Broker URL",
        type: "text",
        required: true,
        placeholder: "tcp://broker:1883",
        group: "Connection",
      },
      {
        key: "topicFilter",
        label: "Topic Filter",
        type: "text",
        required: true,
        placeholder: "sensors/+/temperature",
        helpText: "MQTT topic filter (supports + and # wildcards)",
        group: "Connection",
      },
      {
        key: "qos",
        label: "QoS",
        type: "select",
        required: true,
        defaultValue: "1",
        options: [
          { value: "0", label: "0 - At most once" },
          { value: "1", label: "1 - At least once" },
          { value: "2", label: "2 - Exactly once" },
        ],
        group: "Connection",
      },
      {
        key: "clientId",
        label: "Client ID",
        type: "text",
        required: true,
        placeholder: "lakestream-mqtt-client",
        group: "Connection",
      },
    ],
  },

  "custom-python-source": {
    type: "custom-python-source",
    label: "Custom Python Source",
    description: "Custom source implemented in Python",
    category: "source",
    codeTarget: "sss",
    icon: "Code",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "pythonCode",
        label: "Python Code",
        type: "code",
        required: true,
        codeLanguage: "python",
        placeholder: "# Implement your custom source...",
        helpText: "Python code defining the source (e.g., extending Source)",
        group: "Code",
      },
      {
        key: "outputSchema",
        label: "Output Schema",
        type: "schema-picker",
        required: true,
        helpText: "Schema of records produced by this source",
        group: "Schema",
      },
    ],
  },

  "stream-simulator": {
    type: "stream-simulator",
    label: "Stream Simulator",
    description: "Generate synthetic streaming data for testing without a real source",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Play",
    color: "#3b82f6",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "dataProfile",
        label: "Data Profile",
        type: "select",
        required: true,
        defaultValue: "iot-sensors",
        options: [
          { value: "iot-sensors", label: "IoT Sensors" },
          { value: "clickstream", label: "Clickstream / Web Events" },
          { value: "financial-transactions", label: "Financial Transactions" },
          { value: "ecommerce-orders", label: "E-Commerce Orders" },
          { value: "custom", label: "Custom Schema" },
        ],
        helpText: "Predefined data shape or custom schema",
        group: "Data",
      },
      {
        key: "eventsPerSecond",
        label: "Events Per Second",
        type: "number",
        required: true,
        defaultValue: 10,
        validation: { min: 1, max: 10000 },
        helpText: "Rate of synthetic event generation",
        group: "Rate",
      },
      {
        key: "numPartitions",
        label: "Partitions",
        type: "number",
        required: false,
        defaultValue: 4,
        validation: { min: 1, max: 64 },
        helpText: "Number of parallel partitions for generation",
        group: "Rate",
      },
      {
        key: "customSchema",
        label: "Custom Schema",
        type: "code",
        required: false,
        codeLanguage: "json",
        placeholder: '[{"name": "sensor_id", "type": "STRING", "generator": "uuid"}, {"name": "temperature", "type": "DOUBLE", "generator": "random(20,40)"}]',
        helpText: "JSON array of {name, type, generator} column definitions",
        dependsOn: { field: "dataProfile", value: "custom" },
        group: "Schema",
      },
      {
        key: "seed",
        label: "Random Seed",
        type: "number",
        required: false,
        placeholder: "42",
        helpText: "Optional seed for reproducible data generation",
        group: "Advanced",
      },
      {
        key: "maxEvents",
        label: "Max Events",
        type: "number",
        required: false,
        placeholder: "Unlimited",
        helpText: "Stop after N events (leave empty for unlimited)",
        group: "Advanced",
      },
    ],
  },

  // ============ CEP PATTERNS (12) ============
  "sequence-detector": {
    type: "sequence-detector",
    label: "Sequence Detector",
    description: "Detect ordered sequences of events",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "ListOrdered",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "steps",
        label: "Sequence Steps",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder: '[{"name": "step1", "filter": "event_type = \'A\'"}, {"name": "step2", "filter": "event_type = \'B\'"}]',
        helpText: "JSON array of {name, filter} steps defining the sequence",
        group: "Pattern",
      },
      {
        key: "contiguityMode",
        label: "Contiguity Mode",
        type: "select",
        required: true,
        defaultValue: "strict",
        options: [
          { value: "strict", label: "Strict - No gaps between events" },
          { value: "relaxed", label: "Relaxed - Allow gaps" },
          { value: "non-deterministic", label: "Non-deterministic" },
        ],
        group: "Pattern",
      },
      {
        key: "withinDuration",
        label: "WITHIN Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        helpText: "Maximum time window for the sequence",
        group: "Pattern",
      },
      {
        key: "timeoutAction",
        label: "Timeout Action",
        type: "select",
        required: false,
        defaultValue: "ignore",
        options: [
          { value: "ignore", label: "Ignore" },
          { value: "emit", label: "Emit Partial" },
        ],
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "absence-detector": {
    type: "absence-detector",
    label: "Absence Detector",
    description: "Detect when expected events are missing",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "AlertCircle",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "triggerEventFilter",
        label: "Trigger Event Filter",
        type: "expression",
        required: true,
        placeholder: "event_type = 'heartbeat'",
        helpText: "Expression that starts the absence detection",
        group: "Pattern",
      },
      {
        key: "expectedEventFilter",
        label: "Expected Event Filter",
        type: "expression",
        required: true,
        placeholder: "event_type = 'heartbeat'",
        helpText: "Expression for the event that should have occurred",
        group: "Pattern",
      },
      {
        key: "timeoutDuration",
        label: "Timeout Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        helpText: "Time to wait before considering event absent",
        group: "Pattern",
      },
      {
        key: "withinDuration",
        label: "WITHIN Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "minutes" },
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "count-threshold": {
    type: "count-threshold",
    label: "Count Threshold",
    description: "Trigger when event count exceeds threshold",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Hash",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "eventFilter",
        label: "Event Filter",
        type: "expression",
        required: true,
        placeholder: "event_type = 'login_attempt'",
        group: "Pattern",
      },
      {
        key: "thresholdCount",
        label: "Threshold Count",
        type: "number",
        required: true,
        defaultValue: 10,
        validation: { min: 1 },
        group: "Pattern",
      },
      {
        key: "windowDuration",
        label: "Window Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "velocity-detector": {
    type: "velocity-detector",
    label: "Velocity Detector",
    description: "Detect rate anomalies (events per time unit)",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Gauge",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "eventFilter",
        label: "Event Filter",
        type: "expression",
        required: true,
        placeholder: "event_type = 'api_call'",
        group: "Pattern",
      },
      {
        key: "rateThreshold",
        label: "Rate Threshold",
        type: "number",
        required: true,
        defaultValue: 100,
        validation: { min: 1 },
        group: "Pattern",
      },
      {
        key: "rateUnit",
        label: "Rate Unit",
        type: "select",
        required: true,
        defaultValue: "per_sec",
        options: [
          { value: "per_sec", label: "Per Second" },
          { value: "per_min", label: "Per Minute" },
          { value: "per_hour", label: "Per Hour" },
        ],
        group: "Pattern",
      },
      {
        key: "windowDuration",
        label: "Window Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 1, unit: "minutes" },
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "geofence-location": {
    type: "geofence-location",
    label: "Geofence / Location",
    description: "Spatial event detection (enter/exit/dwell)",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "MapPin",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "latField",
        label: "Latitude Field",
        type: "column-picker",
        required: true,
        placeholder: "Select latitude column",
        group: "Location",
      },
      {
        key: "lonField",
        label: "Longitude Field",
        type: "column-picker",
        required: true,
        placeholder: "Select longitude column",
        group: "Location",
      },
      {
        key: "geofenceType",
        label: "Geofence Type",
        type: "select",
        required: true,
        options: [
          { value: "circle", label: "Circle" },
          { value: "polygon", label: "Polygon" },
        ],
        group: "Geofence",
      },
      {
        key: "radiusMeters",
        label: "Radius (meters)",
        type: "number",
        required: false,
        defaultValue: 100,
        dependsOn: { field: "geofenceType", value: "circle" },
        group: "Geofence",
      },
      {
        key: "centerLat",
        label: "Center Latitude",
        type: "number",
        required: false,
        dependsOn: { field: "geofenceType", value: "circle" },
        group: "Geofence",
      },
      {
        key: "centerLon",
        label: "Center Longitude",
        type: "number",
        required: false,
        dependsOn: { field: "geofenceType", value: "circle" },
        group: "Geofence",
      },
      {
        key: "polygonVertices",
        label: "Polygon Vertices",
        type: "expression",
        required: false,
        placeholder: "[[lat1,lon1],[lat2,lon2],...]",
        dependsOn: { field: "geofenceType", value: "polygon" },
        group: "Geofence",
      },
      {
        key: "trigger",
        label: "Trigger Type",
        type: "select",
        required: true,
        defaultValue: "enter",
        options: [
          { value: "enter", label: "Enter" },
          { value: "exit", label: "Exit" },
          { value: "dwell", label: "Dwell" },
        ],
        group: "Trigger",
      },
      {
        key: "dwellDuration",
        label: "Dwell Duration",
        type: "duration",
        required: false,
        dependsOn: { field: "trigger", value: "dwell" },
        group: "Trigger",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "temporal-correlation": {
    type: "temporal-correlation",
    label: "Temporal Correlation",
    description: "Correlate events from two streams by time",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Clock",
    color: "#8b5cf6",
    inputs: 2,
    outputs: 1,
    configFields: [
      {
        key: "streamAFilter",
        label: "Stream A Filter",
        type: "expression",
        required: true,
        placeholder: "stream = 'A'",
        group: "Pattern",
      },
      {
        key: "streamBFilter",
        label: "Stream B Filter",
        type: "expression",
        required: true,
        placeholder: "stream = 'B'",
        group: "Pattern",
      },
      {
        key: "correlationKey",
        label: "Correlation Key",
        type: "column-picker",
        required: true,
        placeholder: "Select correlation column",
        group: "Pattern",
      },
      {
        key: "maxTimeGap",
        label: "Max Time Gap",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "trend-detector": {
    type: "trend-detector",
    label: "Trend Detector",
    description: "Detect upward/downward trends in numeric values",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "TrendingUp",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "valueField",
        label: "Value Field",
        type: "column-picker",
        required: true,
        placeholder: "Select numeric column",
        group: "Pattern",
      },
      {
        key: "direction",
        label: "Direction",
        type: "select",
        required: true,
        options: [
          { value: "up", label: "Upward" },
          { value: "down", label: "Downward" },
          { value: "flat", label: "Flat" },
        ],
        group: "Pattern",
      },
      {
        key: "consecutiveCount",
        label: "Consecutive Count",
        type: "number",
        required: true,
        defaultValue: 3,
        validation: { min: 2 },
        helpText: "Number of consecutive events to confirm trend",
        group: "Pattern",
      },
      {
        key: "tolerancePercent",
        label: "Tolerance %",
        type: "number",
        required: false,
        defaultValue: 5,
        helpText: "Allowable deviation from trend",
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "outlier-anomaly": {
    type: "outlier-anomaly",
    label: "Outlier / Anomaly",
    description: "Statistical anomaly detection",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Activity",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "valueField",
        label: "Value Field",
        type: "column-picker",
        required: true,
        placeholder: "Select numeric column",
        group: "Pattern",
      },
      {
        key: "baselineWindow",
        label: "Baseline Window",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "minutes" },
        helpText: "Window for computing baseline statistics",
        group: "Pattern",
      },
      {
        key: "thresholdStdDevs",
        label: "Threshold (Std Devs)",
        type: "number",
        required: true,
        defaultValue: 3,
        validation: { min: 1 },
        group: "Pattern",
      },
      {
        key: "algorithm",
        label: "Algorithm",
        type: "select",
        required: true,
        defaultValue: "z-score",
        options: [
          { value: "z-score", label: "Z-Score" },
          { value: "iqr", label: "IQR (Interquartile Range)" },
          { value: "mad", label: "MAD (Median Absolute Deviation)" },
        ],
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "session-detector": {
    type: "session-detector",
    label: "Session Detector",
    description: "Group events into sessions by gap duration",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Users",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "sessionKey",
        label: "Session Key",
        type: "column-picker",
        required: true,
        placeholder: "Select session key column(s)",
        helpText: "Column(s) to partition sessions by",
        group: "Pattern",
      },
      {
        key: "gapDuration",
        label: "Gap Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        helpText: "Maximum gap between events before new session",
        group: "Pattern",
      },
      {
        key: "maxSessionDuration",
        label: "Max Session Duration",
        type: "duration",
        required: false,
        helpText: "Optional cap on session length",
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  deduplication: {
    type: "deduplication",
    label: "Deduplication",
    description: "Remove duplicate events by key",
    category: "cep-pattern",
    codeTarget: "sdp-or-sss",
    icon: "Copy",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "dedupKeyFields",
        label: "Deduplication Key Fields",
        type: "column-picker",
        required: true,
        placeholder: "Select columns for dedup key",
        group: "Pattern",
      },
      {
        key: "watermarkDuration",
        label: "Watermark Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "minutes" },
        helpText: "Watermark for late event handling",
        group: "Pattern",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "match-recognize-sql": {
    type: "match-recognize-sql",
    label: "MATCH_RECOGNIZE SQL",
    description: "SQL-based pattern matching (partition, order, measures, pattern, define)",
    category: "cep-pattern",
    codeTarget: "sdp",
    icon: "FileCode",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "matchRecognizeSql",
        label: "MATCH_RECOGNIZE SQL",
        type: "code",
        required: true,
        codeLanguage: "sql",
        placeholder: "SELECT * FROM stream\nMATCH_RECOGNIZE (\n  PARTITION BY key\n  ORDER BY event_time\n  MEASURES ...\n  PATTERN (A B+ C)\n  DEFINE ...\n  WITHIN INTERVAL '10' MINUTE\n)",
        helpText: "Full MATCH_RECOGNIZE clause (partition by, order by, measures, pattern, define, within)",
        group: "SQL",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  "custom-stateful-processor": {
    type: "custom-stateful-processor",
    label: "Custom StatefulProcessor",
    description: "Custom stateful processing in Python",
    category: "cep-pattern",
    codeTarget: "sss",
    icon: "Cpu",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "pythonCode",
        label: "Python Code",
        type: "code",
        required: true,
        codeLanguage: "python",
        placeholder: "# Extend StatefulProcessor...",
        helpText: "Python code extending StatefulProcessor",
        group: "Code",
      },
      {
        key: "stateSchema",
        label: "State Schema",
        type: "schema-picker",
        required: true,
        helpText: "Schema of the state object",
        group: "State",
      },
      {
        key: "timerConfig",
        label: "Timer Config",
        type: "key-value",
        required: false,
        placeholder: "timer_name: duration",
        group: "State",
      },
    ],
    advancedFields: CEP_ADVANCED_FIELDS,
  },

  // ============ TRANSFORMS (10) ============
  filter: {
    type: "filter",
    label: "Filter",
    description: "Filter events by SQL WHERE condition",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Filter",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "condition",
        label: "Condition",
        type: "expression",
        required: true,
        placeholder: "amount > 100 AND status = 'active'",
        helpText: "SQL WHERE expression",
        group: "Filter",
      },
    ],
  },

  "map-select": {
    type: "map-select",
    label: "Map / Select",
    description: "Transform or select columns with expressions",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Columns",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "outputColumns",
        label: "Output Columns",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder: '["col1", "col2 AS alias", "col3 * 2 AS doubled"]',
        helpText: "JSON array of column expressions",
        group: "Columns",
      },
    ],
  },

  "flatten-explode": {
    type: "flatten-explode",
    label: "Flatten / Explode",
    description: "Explode arrays or structs into rows",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Expand",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "arrayOrStructField",
        label: "Array/Struct Field",
        type: "column-picker",
        required: true,
        placeholder: "Select field to explode",
        group: "Explode",
      },
      {
        key: "outputAlias",
        label: "Output Alias",
        type: "text",
        required: false,
        placeholder: "item",
        helpText: "Alias for the exploded element",
        group: "Explode",
      },
    ],
  },

  "lookup-enrichment": {
    type: "lookup-enrichment",
    label: "Lookup Enrichment",
    description: "Enrich stream with lookup table",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Search",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "lookupTable",
        label: "Lookup Table",
        type: "text",
        required: true,
        placeholder: "catalog.schema.table",
        group: "Lookup",
      },
      {
        key: "joinKeys",
        label: "Join Keys",
        type: "column-picker",
        required: true,
        placeholder: "Select join key columns",
        group: "Lookup",
      },
      {
        key: "joinType",
        label: "Join Type",
        type: "select",
        required: true,
        defaultValue: "left",
        options: [
          { value: "left", label: "Left" },
          { value: "inner", label: "Inner" },
          { value: "right", label: "Right" },
        ],
        group: "Lookup",
      },
    ],
  },

  "window-aggregate": {
    type: "window-aggregate",
    label: "Window Aggregate",
    description: "Aggregate over time windows",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "LayoutGrid",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "windowType",
        label: "Window Type",
        type: "select",
        required: true,
        defaultValue: "tumbling",
        options: [
          { value: "tumbling", label: "Tumbling" },
          { value: "sliding", label: "Sliding" },
          { value: "session", label: "Session" },
        ],
        group: "Window",
      },
      {
        key: "duration",
        label: "Window Duration",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        group: "Window",
      },
      {
        key: "slideInterval",
        label: "Slide Interval",
        type: "duration",
        required: false,
        dependsOn: { field: "windowType", value: "sliding" },
        group: "Window",
      },
      {
        key: "groupByKeys",
        label: "Group By Keys",
        type: "column-picker",
        required: false,
        placeholder: "Select group-by columns",
        group: "Aggregation",
      },
      {
        key: "aggregations",
        label: "Aggregations",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder: '[{"column": "amount", "function": "sum"}, {"column": "id", "function": "count"}]',
        helpText: "JSON array of {column, function} (sum, count, avg, min, max, etc.)",
        group: "Aggregation",
      },
    ],
  },

  "stream-stream-join": {
    type: "stream-stream-join",
    label: "Stream-Stream Join",
    description: "Join two streaming datasets",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "GitMerge",
    color: "#22c55e",
    inputs: 2,
    outputs: 1,
    configFields: [
      {
        key: "joinCondition",
        label: "Join Condition",
        type: "expression",
        required: true,
        placeholder: "left.key = right.key",
        group: "Join",
      },
      {
        key: "joinType",
        label: "Join Type",
        type: "select",
        required: true,
        defaultValue: "inner",
        options: [
          { value: "inner", label: "Inner" },
          { value: "left", label: "Left" },
          { value: "right", label: "Right" },
          { value: "full", label: "Full Outer" },
        ],
        group: "Join",
      },
      {
        key: "leftWatermark",
        label: "Left Watermark",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "minutes" },
        group: "Watermark",
      },
      {
        key: "rightWatermark",
        label: "Right Watermark",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "minutes" },
        group: "Watermark",
      },
    ],
  },

  "stream-static-join": {
    type: "stream-static-join",
    label: "Stream-Static Join",
    description: "Join stream with static/batch table",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Link",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "staticTable",
        label: "Static Table",
        type: "text",
        required: true,
        placeholder: "catalog.schema.table",
        group: "Join",
      },
      {
        key: "joinKeys",
        label: "Join Keys",
        type: "column-picker",
        required: true,
        placeholder: "Select join key columns",
        group: "Join",
      },
      {
        key: "joinType",
        label: "Join Type",
        type: "select",
        required: true,
        defaultValue: "left",
        options: [
          { value: "left", label: "Left" },
          { value: "inner", label: "Inner" },
          { value: "right", label: "Right" },
        ],
        group: "Join",
      },
    ],
  },

  "union-merge": {
    type: "union-merge",
    label: "Union / Merge",
    description: "Combine multiple streams into one (2â€“8 inputs)",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Combine",
    color: "#22c55e",
    inputs: 8,
    outputs: 1,
    configFields: [
      {
        key: "unionType",
        label: "Union Type",
        type: "select",
        required: false,
        defaultValue: "union-all",
        options: [
          { value: "union-all", label: "UNION ALL (keep duplicates)" },
          { value: "union-distinct", label: "UNION (deduplicate)" },
        ],
        helpText: "How to combine the incoming streams",
        group: "Union",
      },
    ],
  },

  "rename-cast": {
    type: "rename-cast",
    label: "Rename / Cast",
    description: "Rename or cast columns",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Type",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "columnMappings",
        label: "Column Mappings",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder: '[{"from": "old_name", "to": "new_name", "castType": "STRING"}, {"from": "amount", "to": "amount", "castType": "DOUBLE"}]',
        helpText: "JSON array of {from, to, castType}",
        group: "Columns",
      },
    ],
  },

  "custom-python-udf": {
    type: "custom-python-udf",
    label: "Custom Python UDF",
    description: "Custom Python transformation function",
    category: "transform",
    codeTarget: "sss",
    icon: "FunctionSquare",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "pythonCode",
        label: "Python Function Code",
        type: "code",
        required: true,
        codeLanguage: "python",
        placeholder: "def transform(record):\n    return record",
        group: "Code",
      },
      {
        key: "inputColumns",
        label: "Input Columns",
        type: "column-picker",
        required: true,
        placeholder: "Select input columns",
        group: "Schema",
      },
      {
        key: "outputColumn",
        label: "Output Column",
        type: "text",
        required: true,
        placeholder: "result",
        group: "Schema",
      },
      {
        key: "outputType",
        label: "Output Type",
        type: "select",
        required: true,
        options: [
          { value: "STRING", label: "String" },
          { value: "LONG", label: "Long" },
          { value: "DOUBLE", label: "Double" },
          { value: "BOOLEAN", label: "Boolean" },
          { value: "TIMESTAMP", label: "Timestamp" },
        ],
        group: "Schema",
      },
    ],
  },

  "ml-model-endpoint": {
    type: "ml-model-endpoint",
    label: "ML Model Endpoint",
    description: "Score events against a Databricks Model Serving endpoint for real-time predictions",
    category: "transform",
    codeTarget: "sss",
    icon: "Brain",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "endpointName",
        label: "Serving Endpoint Name",
        type: "text",
        required: true,
        placeholder: "fraud-detection-model",
        helpText: "Databricks Model Serving endpoint name",
        group: "Endpoint",
      },
      {
        key: "inputColumns",
        label: "Feature Columns",
        type: "column-picker",
        required: true,
        placeholder: "Select columns to send as model features",
        helpText: "Columns passed as input features to the model",
        group: "Input",
      },
      {
        key: "outputColumn",
        label: "Prediction Column",
        type: "text",
        required: true,
        defaultValue: "prediction",
        placeholder: "prediction",
        helpText: "Column name for the model prediction result",
        group: "Output",
      },
      {
        key: "outputType",
        label: "Prediction Type",
        type: "select",
        required: true,
        defaultValue: "DOUBLE",
        options: [
          { value: "STRING", label: "String" },
          { value: "DOUBLE", label: "Double" },
          { value: "BOOLEAN", label: "Boolean" },
          { value: "LONG", label: "Long" },
          { value: "STRUCT", label: "Struct (JSON)" },
        ],
        group: "Output",
      },
      {
        key: "maxBatchSize",
        label: "Max Batch Size",
        type: "number",
        required: false,
        defaultValue: 100,
        validation: { min: 1, max: 10000 },
        helpText: "Max rows per scoring request (batched for throughput)",
        group: "Performance",
      },
      {
        key: "timeoutMs",
        label: "Timeout (ms)",
        type: "number",
        required: false,
        defaultValue: 30000,
        validation: { min: 1000, max: 300000 },
        helpText: "HTTP timeout per scoring request",
        group: "Performance",
      },
      {
        key: "concurrency",
        label: "Concurrency",
        type: "number",
        required: false,
        defaultValue: 4,
        validation: { min: 1, max: 64 },
        helpText: "Parallel scoring requests per partition",
        group: "Performance",
      },
      {
        key: "fallbackValue",
        label: "Fallback Value",
        type: "text",
        required: false,
        placeholder: "null",
        helpText: "Value to use if the model endpoint returns an error",
        group: "Error Handling",
      },
    ],
  },

  // ============ SINKS (9) ============
  "delta-table-sink": {
    type: "delta-table-sink",
    label: "Delta Table Sink",
    description: "Write to Delta table",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Database",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "catalog",
        label: "Catalog",
        type: "text",
        required: true,
        placeholder: "main",
        group: "Table",
      },
      {
        key: "schema",
        label: "Schema",
        type: "text",
        required: true,
        placeholder: "default",
        group: "Table",
      },
      {
        key: "table",
        label: "Table",
        type: "text",
        required: true,
        placeholder: "my_table",
        group: "Table",
      },
      {
        key: "writeMode",
        label: "Write Mode",
        type: "select",
        required: true,
        defaultValue: "append",
        options: [
          { value: "append", label: "Append" },
          { value: "merge", label: "Merge" },
          { value: "upsert", label: "Upsert" },
        ],
        group: "Write",
      },
      {
        key: "mergeKeys",
        label: "Merge Keys",
        type: "column-picker",
        required: false,
        dependsOn: { field: "writeMode", values: ["merge", "upsert"] },
        helpText: "Required for merge/upsert modes",
        group: "Write",
      },
      {
        key: "partitionColumns",
        label: "Partition Columns",
        type: "column-picker",
        required: false,
        placeholder: "Select partition columns",
        group: "Write",
      },
    ],
  },

  "kafka-topic-sink": {
    type: "kafka-topic-sink",
    label: "Kafka Topic Sink",
    description: "Write to Kafka topic",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "MessageSquare",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "bootstrapServers",
        label: "Bootstrap Servers",
        type: "text",
        required: true,
        placeholder: "host1:9092,host2:9092",
        group: "Connection",
      },
      {
        key: "topic",
        label: "Topic",
        type: "text",
        required: true,
        placeholder: "output-topic",
        group: "Connection",
      },
      {
        key: "serializationFormat",
        label: "Serialization Format",
        type: "select",
        required: true,
        defaultValue: "json",
        options: [
          { value: "json", label: "JSON" },
          { value: "avro", label: "Avro" },
          { value: "protobuf", label: "Protobuf" },
        ],
        group: "Format",
      },
      {
        key: "keyExpression",
        label: "Key Expression",
        type: "expression",
        required: false,
        placeholder: "record.id or null",
        helpText: "Expression for Kafka message key",
        group: "Format",
      },
    ],
  },

  "rest-webhook-sink": {
    type: "rest-webhook-sink",
    label: "REST/Webhook Sink",
    description: "Send events to HTTP endpoint",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Webhook",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "url",
        label: "URL",
        type: "text",
        required: true,
        placeholder: "https://api.example.com/events",
        group: "Connection",
      },
      {
        key: "method",
        label: "HTTP Method",
        type: "select",
        required: true,
        defaultValue: "POST",
        options: [
          { value: "POST", label: "POST" },
          { value: "PUT", label: "PUT" },
        ],
        group: "Connection",
      },
      {
        key: "headers",
        label: "Headers",
        type: "key-value",
        required: false,
        placeholder: "Content-Type: application/json",
        group: "Connection",
      },
      {
        key: "authType",
        label: "Auth Type",
        type: "select",
        required: false,
        defaultValue: "none",
        options: [
          { value: "none", label: "None" },
          { value: "bearer", label: "Bearer Token" },
          { value: "basic", label: "Basic Auth" },
        ],
        group: "Auth",
      },
      {
        key: "authSecret",
        label: "Bearer Token",
        type: "text",
        required: false,
        placeholder: "Token value",
        dependsOn: { field: "authType", value: "bearer" },
        group: "Auth",
      },
      {
        key: "basicAuthUsername",
        label: "Username",
        type: "text",
        required: false,
        placeholder: "username",
        dependsOn: { field: "authType", value: "basic" },
        group: "Auth",
      },
      {
        key: "basicAuthPassword",
        label: "Password",
        type: "text",
        required: false,
        placeholder: "password",
        dependsOn: { field: "authType", value: "basic" },
        group: "Auth",
      },
      {
        key: "payloadTemplate",
        label: "Payload Template",
        type: "expression",
        required: false,
        placeholder: "JSON template with {{column}} placeholders",
        group: "Payload",
      },
    ],
  },

  "slack-teams-pagerduty": {
    type: "slack-teams-pagerduty",
    label: "Slack / Teams / PagerDuty",
    description: "Send alert notifications",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Bell",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "provider",
        label: "Provider",
        type: "select",
        required: true,
        options: [
          { value: "slack", label: "Slack" },
          { value: "teams", label: "Microsoft Teams" },
          { value: "pagerduty", label: "PagerDuty" },
        ],
        group: "Connection",
      },
      {
        key: "webhookUrl",
        label: "Webhook URL",
        type: "text",
        required: true,
        placeholder: "https://hooks.slack.com/...",
        group: "Connection",
      },
      {
        key: "messageTemplate",
        label: "Message Template",
        type: "expression",
        required: true,
        placeholder: "Alert: {{message}} at {{timestamp}}",
        helpText: "Template with {{column}} placeholders",
        group: "Message",
      },
    ],
  },

  "email-sink": {
    type: "email-sink",
    label: "Email Sink",
    description: "Send email notifications",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Mail",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "smtpProvider",
        label: "SMTP Provider",
        type: "select",
        required: true,
        options: [
          { value: "smtp", label: "Custom SMTP" },
          { value: "sendgrid", label: "SendGrid" },
        ],
        group: "Connection",
      },
      {
        key: "smtpServer",
        label: "SMTP Server",
        type: "text",
        required: false,
        placeholder: "smtp.example.com:587",
        dependsOn: { field: "smtpProvider", value: "smtp" },
        group: "Connection",
      },
      {
        key: "smtpPort",
        label: "SMTP Port",
        type: "number",
        required: false,
        defaultValue: 587,
        dependsOn: { field: "smtpProvider", value: "smtp" },
        group: "Connection",
      },
      {
        key: "sendgridApiKey",
        label: "SendGrid API Key",
        type: "text",
        required: false,
        placeholder: "SG.xxx",
        dependsOn: { field: "smtpProvider", value: "sendgrid" },
        helpText: "SendGrid API key for authentication",
        group: "Connection",
      },
      {
        key: "to",
        label: "To",
        type: "text",
        required: true,
        placeholder: "alerts@example.com",
        group: "Email",
      },
      {
        key: "subjectTemplate",
        label: "Subject Template",
        type: "expression",
        required: true,
        placeholder: "Alert: {{alert_type}}",
        group: "Email",
      },
      {
        key: "bodyTemplate",
        label: "Body Template",
        type: "expression",
        required: true,
        placeholder: "Event: {{message}}",
        group: "Email",
      },
    ],
  },

  "sql-warehouse-sink": {
    type: "sql-warehouse-sink",
    label: "SQL Warehouse Sink",
    description: "Write to Databricks SQL Warehouse table",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Server",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "warehouseId",
        label: "Warehouse ID",
        type: "text",
        required: true,
        placeholder: "abc123def456",
        group: "Connection",
      },
      {
        key: "catalog",
        label: "Catalog",
        type: "text",
        required: true,
        placeholder: "main",
        group: "Table",
      },
      {
        key: "schema",
        label: "Schema",
        type: "text",
        required: true,
        placeholder: "default",
        group: "Table",
      },
      {
        key: "table",
        label: "Table",
        type: "text",
        required: true,
        placeholder: "my_table",
        group: "Table",
      },
    ],
  },

  "unity-catalog-table-sink": {
    type: "unity-catalog-table-sink",
    label: "Unity Catalog Table Sink",
    description: "Write to Unity Catalog table",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Shield",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "catalog",
        label: "Catalog",
        type: "text",
        required: true,
        placeholder: "main",
        group: "Table",
      },
      {
        key: "schema",
        label: "Schema",
        type: "text",
        required: true,
        placeholder: "default",
        group: "Table",
      },
      {
        key: "table",
        label: "Table",
        type: "text",
        required: true,
        placeholder: "my_table",
        group: "Table",
      },
      {
        key: "writeMode",
        label: "Write Mode",
        type: "select",
        required: true,
        defaultValue: "append",
        options: [
          { value: "append", label: "Append" },
          { value: "overwrite", label: "Overwrite" },
        ],
        group: "Write",
      },
    ],
  },

  "dead-letter-queue": {
    type: "dead-letter-queue",
    label: "Dead Letter Queue",
    description: "Route failed events for retry or analysis",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "AlertTriangle",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "target",
        label: "Target",
        type: "select",
        required: true,
        options: [
          { value: "delta", label: "Delta Table" },
          { value: "kafka", label: "Kafka Topic" },
        ],
        group: "Target",
      },
      {
        key: "deltaTable",
        label: "Delta Table",
        type: "text",
        required: false,
        placeholder: "catalog.schema.dlq_table",
        dependsOn: { field: "target", value: "delta" },
        group: "Target",
      },
      {
        key: "kafkaTopic",
        label: "Kafka Topic",
        type: "text",
        required: false,
        placeholder: "dlq-topic",
        dependsOn: { field: "target", value: "kafka" },
        group: "Target",
      },
      {
        key: "includeErrorInfo",
        label: "Include Error Info",
        type: "toggle",
        required: false,
        defaultValue: true,
        helpText: "Include error message and stack trace",
        group: "Options",
      },
    ],
  },

  "lakebase-sink": {
    type: "lakebase-sink",
    label: "Lakebase Sink",
    description: "Write to Databricks Lakebase (serverless PostgreSQL) with streaming tables, materialized views, and data quality expectations",
    category: "sink",
    codeTarget: "sdp-or-sss",
    icon: "Warehouse",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "catalog",
        label: "Catalog",
        type: "text",
        required: true,
        placeholder: "main",
        group: "Table",
      },
      {
        key: "schema",
        label: "Schema",
        type: "text",
        required: true,
        placeholder: "default",
        group: "Table",
      },
      {
        key: "table",
        label: "Table",
        type: "text",
        required: true,
        placeholder: "my_lakehouse_table",
        group: "Table",
      },
      {
        key: "tableType",
        label: "Table Type",
        type: "select",
        required: true,
        defaultValue: "streaming-table",
        options: [
          { value: "streaming-table", label: "Streaming Table" },
          { value: "materialized-view", label: "Materialized View" },
          { value: "live-table", label: "Live Table" },
        ],
        helpText: "Lakehouse object type for the sink",
        group: "Table",
      },
      {
        key: "writeMode",
        label: "Write Mode",
        type: "select",
        required: true,
        defaultValue: "append",
        options: [
          { value: "append", label: "Append" },
          { value: "merge", label: "Merge (SCD Type 1)" },
          { value: "upsert", label: "Upsert" },
          { value: "complete", label: "Complete (Overwrite)" },
        ],
        group: "Write",
      },
      {
        key: "mergeKeys",
        label: "Merge Keys",
        type: "column-picker",
        required: false,
        dependsOn: { field: "writeMode", values: ["merge", "upsert"] },
        helpText: "Required for merge/upsert modes",
        group: "Write",
      },
      {
        key: "partitionColumns",
        label: "Partition Columns",
        type: "column-picker",
        required: false,
        placeholder: "Select partition columns",
        group: "Storage",
      },
      {
        key: "clusteringColumns",
        label: "Liquid Clustering Columns",
        type: "column-picker",
        required: false,
        placeholder: "Select clustering columns",
        helpText: "Columns for Delta liquid clustering (recommended over partitioning)",
        group: "Storage",
      },
      {
        key: "expectations",
        label: "Data Quality Expectations",
        type: "code",
        required: false,
        codeLanguage: "json",
        placeholder: '[{"name": "valid_amount", "constraint": "amount > 0", "action": "drop"}]',
        helpText: "JSON array of {name, constraint, action} â€” action: drop, fail, or warn",
        group: "Quality",
      },
    ],
  },

  // ============ NEW: GOOGLE PUB/SUB SOURCE ============
  "google-pubsub": {
    type: "google-pubsub",
    label: "Google Pub/Sub",
    description: "Subscribe to Google Cloud Pub/Sub topics for streaming events",
    category: "source",
    codeTarget: "sdp-or-sss",
    icon: "Cloud",
    color: "#60a5fa",
    inputs: 0,
    outputs: 1,
    configFields: [
      {
        key: "projectId",
        label: "GCP Project ID",
        type: "text",
        required: true,
        placeholder: "my-gcp-project",
        group: "Connection",
      },
      {
        key: "subscriptionId",
        label: "Subscription ID",
        type: "text",
        required: true,
        placeholder: "my-subscription",
        helpText: "Pub/Sub subscription name",
        group: "Connection",
      },
      {
        key: "credentialsPath",
        label: "Credentials Path",
        type: "text",
        required: false,
        placeholder: "/dbfs/keys/gcp-service-account.json",
        helpText:
          "Path to GCP service account JSON key file (optional if using Databricks secrets)",
        group: "Connection",
      },
      {
        key: "deserializationFormat",
        label: "Deserialization Format",
        type: "select",
        required: true,
        defaultValue: "json",
        options: [
          { value: "json", label: "JSON" },
          { value: "avro", label: "Avro" },
          { value: "protobuf", label: "Protobuf" },
          { value: "text", label: "Plain Text" },
        ],
        group: "Format",
      },
    ],
  },

  // ============ NEW: CEP PATTERN â€“ STATE MACHINE ============
  "state-machine": {
    type: "state-machine",
    label: "State Machine",
    description:
      "Multi-state FSM with named transitions (e.g. idle â†’ active â†’ alert â†’ resolved)",
    category: "cep-pattern",
    codeTarget: "sss",
    icon: "GitBranch",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "states",
        label: "States",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder: '["idle", "active", "alert", "resolved"]',
        helpText: "JSON array of state names. First state is the initial state.",
        group: "FSM",
      },
      {
        key: "transitions",
        label: "Transitions",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder:
          '[{"from": "idle", "to": "active", "condition": "event_type = \'start\'"}, {"from": "active", "to": "alert", "condition": "severity > 5"}]',
        helpText: "JSON array of {from, to, condition} transition rules",
        group: "FSM",
      },
      {
        key: "keyColumn",
        label: "Entity Key",
        type: "text",
        required: true,
        placeholder: "device_id",
        helpText:
          "Column used to track state per entity (e.g. device_id, user_id)",
        group: "FSM",
      },
      {
        key: "emitOn",
        label: "Emit On",
        type: "select",
        required: true,
        defaultValue: "transition",
        options: [
          { value: "transition", label: "Every Transition" },
          { value: "terminal", label: "Terminal States Only" },
          { value: "all", label: "All Events" },
        ],
        helpText: "When to emit output events",
        group: "FSM",
      },
      {
        key: "terminalStates",
        label: "Terminal States",
        type: "text",
        required: false,
        placeholder: "resolved, closed",
        helpText:
          "Comma-separated list of states that end the FSM (used with 'Terminal States Only' emit mode)",
        group: "FSM",
      },
      {
        key: "stateTimeout",
        label: "State Timeout",
        type: "duration",
        required: false,
        defaultValue: { value: 30, unit: "minutes" },
        helpText:
          "Reset to initial state if no event within this duration",
        group: "FSM",
      },
    ],
    advancedFields: [
      {
        key: "groupByKeys",
        label: "Group By Keys",
        type: "text",
        required: false,
        placeholder: "device_id, region",
        helpText: "Additional columns to partition state by",
        group: "Advanced",
      },
      {
        key: "watermarkDuration",
        label: "Watermark Duration",
        type: "duration",
        required: false,
        defaultValue: { value: 10, unit: "seconds" },
        group: "Advanced",
      },
    ],
  },

  // ============ NEW: CEP PATTERN â€“ HEARTBEAT / LIVENESS ============
  "heartbeat-liveness": {
    type: "heartbeat-liveness",
    label: "Heartbeat / Liveness",
    description:
      "Alert when no event is received from an entity within a time window",
    category: "cep-pattern",
    codeTarget: "sss",
    icon: "HeartPulse",
    color: "#8b5cf6",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "entityKey",
        label: "Entity Key",
        type: "text",
        required: true,
        placeholder: "device_id",
        helpText:
          "Column identifying the entity (device, sensor, user)",
        group: "Liveness",
      },
      {
        key: "expectedInterval",
        label: "Expected Interval",
        type: "duration",
        required: true,
        defaultValue: { value: 5, unit: "minutes" },
        helpText: "Maximum expected time between heartbeats",
        group: "Liveness",
      },
      {
        key: "gracePeriod",
        label: "Grace Period",
        type: "duration",
        required: false,
        defaultValue: { value: 1, unit: "minutes" },
        helpText:
          "Additional buffer before declaring entity as dead",
        group: "Liveness",
      },
      {
        key: "outputMode",
        label: "Output Mode",
        type: "select",
        required: true,
        defaultValue: "dead-only",
        options: [
          {
            value: "dead-only",
            label: "Dead Only â€” emit when entity goes silent",
          },
          {
            value: "alive-and-dead",
            label: "Alive & Dead â€” emit status for all",
          },
          {
            value: "status-change",
            label: "Status Change â€” emit on aliveâ†”dead transitions",
          },
        ],
        group: "Liveness",
      },
    ],
    advancedFields: [
      {
        key: "groupByKeys",
        label: "Group By Keys",
        type: "text",
        required: false,
        placeholder: "region, fleet_id",
        group: "Advanced",
      },
      {
        key: "watermarkDuration",
        label: "Watermark Duration",
        type: "duration",
        required: false,
        defaultValue: { value: 10, unit: "seconds" },
        group: "Advanced",
      },
    ],
  },

  // ============ NEW: TRANSFORM â€“ SPLIT / ROUTER ============
  "split-router": {
    type: "split-router",
    label: "Split / Router",
    description:
      "Route events to different outputs based on conditions (1 input â†’ multiple outputs)",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Split",
    color: "#22c55e",
    inputs: 1,
    outputs: 4,
    configFields: [
      {
        key: "routes",
        label: "Routes",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder:
          '[{"name": "high_value", "condition": "amount > 1000"}, {"name": "low_value", "condition": "amount <= 1000"}]',
        helpText:
          "JSON array of {name, condition} routes. Events matching a condition are sent to that output. Unmatched events go to the default output.",
        group: "Routing",
      },
      {
        key: "defaultRoute",
        label: "Default Route Name",
        type: "text",
        required: false,
        defaultValue: "other",
        placeholder: "other",
        helpText:
          "Name for events that don't match any route condition",
        group: "Routing",
      },
    ],
  },

  // ============ NEW: TRANSFORM â€“ WATERMARK ============
  watermark: {
    type: "watermark",
    label: "Watermark",
    description:
      "Configure event-time watermark for late data handling",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "Clock",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "timestampColumn",
        label: "Timestamp Column",
        type: "text",
        required: true,
        placeholder: "event_time",
        helpText: "Column containing the event timestamp",
        group: "Watermark",
      },
      {
        key: "delayThreshold",
        label: "Delay Threshold",
        type: "duration",
        required: true,
        defaultValue: { value: 10, unit: "seconds" },
        helpText:
          "Maximum expected delay â€” events arriving later than this are dropped",
        group: "Watermark",
      },
    ],
  },

  // ============ NEW: TRANSFORM â€“ DATA QUALITY ============
  "data-quality-expectations": {
    type: "data-quality-expectations",
    label: "Data Quality",
    description:
      "Apply inline DLT expectations (expect, expect_or_drop, expect_or_fail)",
    category: "transform",
    codeTarget: "sdp-or-sss",
    icon: "ShieldCheck",
    color: "#22c55e",
    inputs: 1,
    outputs: 1,
    configFields: [
      {
        key: "expectations",
        label: "Expectations",
        type: "code",
        required: true,
        codeLanguage: "json",
        placeholder:
          '[{"name": "valid_id", "constraint": "id IS NOT NULL", "action": "drop"}, {"name": "positive_amount", "constraint": "amount > 0", "action": "fail"}]',
        helpText:
          "JSON array of {name, constraint, action}. Actions: warn (log only), drop (filter out), fail (abort pipeline)",
        group: "Quality",
      },
      {
        key: "quarantineTable",
        label: "Quarantine Table",
        type: "text",
        required: false,
        placeholder: "catalog.schema.quarantine_events",
        helpText:
          "Optional table to write rejected rows to (for 'drop' actions)",
        group: "Quality",
      },
    ],
  },

  // ============ NEW: SINK â€“ FEATURE STORE ============
  "feature-store-sink": {
    type: "feature-store-sink",
    label: "Feature Store Sink",
    description:
      "Write features to Databricks Feature Store for ML model serving",
    category: "sink",
    codeTarget: "sss",
    icon: "Layers",
    color: "#f97316",
    inputs: 1,
    outputs: 0,
    configFields: [
      {
        key: "featureTableName",
        label: "Feature Table Name",
        type: "text",
        required: true,
        placeholder: "catalog.schema.user_features",
        helpText: "Fully qualified Unity Catalog feature table name",
        group: "Feature Store",
      },
      {
        key: "primaryKeys",
        label: "Primary Keys",
        type: "text",
        required: true,
        placeholder: "user_id",
        helpText: "Comma-separated list of primary key columns",
        group: "Feature Store",
      },
      {
        key: "timestampKey",
        label: "Timestamp Key",
        type: "text",
        required: false,
        placeholder: "event_time",
        helpText:
          "Timestamp column for time-series feature tables (enables point-in-time lookups)",
        group: "Feature Store",
      },
      {
        key: "description",
        label: "Table Description",
        type: "text",
        required: false,
        placeholder: "Real-time user features for fraud model",
        group: "Feature Store",
      },
      {
        key: "writeMode",
        label: "Write Mode",
        type: "select",
        required: true,
        defaultValue: "merge",
        options: [
          { value: "merge", label: "Merge (upsert by primary keys)" },
          { value: "overwrite", label: "Overwrite" },
        ],
        group: "Write",
      },
    ],
  },
};